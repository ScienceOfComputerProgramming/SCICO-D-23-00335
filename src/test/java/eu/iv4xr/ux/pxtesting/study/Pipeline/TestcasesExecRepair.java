package eu.iv4xr.ux.pxtesting.study.Pipeline;

import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.Test;

import agents.EventsProducer;
import agents.LabRecruitsTestAgent;
import alice.tuprolog.Int;
import environments.LabRecruitsConfig;
import environments.LabRecruitsEnvironment;
import eu.fbk.iv4xr.mbt.MBTProperties;
import eu.fbk.iv4xr.mbt.MBTProperties.LR_random_mode;
import eu.fbk.iv4xr.mbt.efsm.EFSM;
import eu.fbk.iv4xr.mbt.efsm.EFSMFactory;
import eu.fbk.iv4xr.mbt.efsm.EFSMOperation;
import eu.fbk.iv4xr.mbt.efsm.EFSMState;
import eu.fbk.iv4xr.mbt.efsm.EFSMTransition;
import eu.fbk.iv4xr.mbt.efsm.exp.Assign;
import eu.fbk.iv4xr.mbt.efsm.exp.Var;
import eu.fbk.iv4xr.mbt.efsm.exp.integer.IntSum;
import eu.fbk.iv4xr.mbt.efsm.labRecruits.LabRecruitsRandomEFSM;
import eu.fbk.iv4xr.mbt.efsm.labRecruits.LabRecruitsRandomEFSM.StateType;
import eu.fbk.iv4xr.mbt.efsm.exp.Const;
import eu.fbk.iv4xr.mbt.testcase.AbstractTestSequence;
import eu.fbk.iv4xr.mbt.testcase.MBTChromosome;
import eu.fbk.iv4xr.mbt.testsuite.SuiteChromosome;
import eu.fbk.iv4xr.mbt.testcase.Path;
import eu.fbk.iv4xr.mbt.utils.TestSerializationUtils;
import eu.iv4xr.framework.extensions.occ.Emotion;
import eu.iv4xr.framework.extensions.occ.EmotionAppraisalSystem;
import eu.iv4xr.framework.extensions.occ.Emotion.EmotionType;
import eu.iv4xr.framework.extensions.occ.Event.Tick;
import eu.iv4xr.framework.mainConcepts.TestAgent;
import eu.iv4xr.framework.mainConcepts.TestDataCollector;
import eu.iv4xr.framework.mainConcepts.WorldEntity;
import eu.iv4xr.framework.spatial.Vec3;
import eu.iv4xr.ux.pxtesting.mbt.Distance;
import eu.iv4xr.ux.pxtesting.study.labrecruits.CSVlevelImport;
import eu.iv4xr.ux.pxtesting.study.labrecruits.LREvent;
import eu.iv4xr.ux.pxtesting.study.labrecruits.PlayerOneCharacterization;
import eu.iv4xr.ux.pxtesting.study.labrecruits.levelsize;
import eu.iv4xr.ux.pxtesting.study.labrecruits.PlayerOneCharacterization.EmotionBeliefBase;
import game.LabRecruitsTestServer;
import game.Platform;
import eu.fbk.iv4xr.mbt.execution.labrecruits.LabRecruitsTestSuiteExecutor;
import nl.uu.cs.aplib.mainConcepts.Goal;
import nl.uu.cs.aplib.mainConcepts.GoalStructure;
import nl.uu.cs.aplib.mainConcepts.GoalStructure.PrimitiveGoal;
import static nl.uu.cs.aplib.mainConcepts.GoalTacticUtils.* ;
import nl.uu.cs.aplib.multiAgentSupport.Message;
import nl.uu.cs.aplib.utils.CSVUtility;

import static nl.uu.cs.aplib.AplibEDSL.* ;
import world.BeliefState;
import static agents.tactics.MyGoalAndTacticLib.* ;
import static eu.iv4xr.ux.pxtesting.study.labrecruits.PlayerOneCharacterization.gotAsMuchPointsAsPossible;
import static eu.iv4xr.ux.pxtesting.study.labrecruits.PlayerOneCharacterization.questIsCompleted;
import static eu.iv4xr.ux.pxtesting.utils.CSVExport.exportToCSV;

/**
 * This contains an implementation to fix MBT test-cases runs that terminate prematurely
 * because they time-out, or because the agent got stuck. For each test-case that 
 * ends prematurely because it timed-out, the fixer retry the test-case with increased
 * time-budget. If it times-out again, the fixer retries with yet more budget. This is
 * repeated until some max-budget, afterwhich the fixer gives up.
 * 
 * For each test-case that gets stuck, the fixer retries it with the same budget, and
 * hopes it gets lucky this time. This is retried several times before the fixer gives
 * up. The fixer also implements some fixing on the goal-structures that implements
 * the test-case. The fixing scans the goal-structures to replace few tactics there
 * with some a variant that is supposed to be less stuck-prone.
 * 
 * The fixer works by scanning the emotion-trace files generated by the test-cases.
 * From these traces the fixer determines which ones need fixing; for those that need
 * fixing the fixer will re-run the corresponding testcase as described above.
 * 
 * The main API for the fixer is the method: fixTestCasesRuns(...)
 * 
 * Important:
 *    (1) it assumes the trace-files are placed in the root-dir of this project.
 *    (2) each trace file is named "data_goalQuestCompleted_tname.csv" where tname
 *        is the name of the test-case. This name should correspond to the name
 *        of the test-case in its serialized file; so we should have the corresponding
 *        "tname.ser".
 *    (3) All the test-cases .ser files are located in projectroot/Combinedtest/
 *    (4) Target LR level is located in projectroot/Combinedtest/Model
 *    
 * Example use:   
 *    
 *      new TestcaseExecRepair()
 *      . fixTestCasesRuns(false,"level-name",500,500,2000,2);
 *      
 *  This run the fixer with no graphics (the "false" flag), specifying that the original
 *  traces were produced with budget 500.
 *  The second 500 specifies that when the fixer retries time-out cases it will increases
 *  the budget with 500 turns. The 2000 part specifies that 2000 is the max-budget the
 *  fixer will try.
 *  The 2 is the maximum number of retries for the stuck-cases.    
 * 
 */ 
public class TestcasesExecRepair {
	
	boolean withGraphics = false ;

	// locations:
	String rootFolder   = new File(System.getProperty("user.dir")).getParent();
    String testFolder   = rootFolder + File.separator + "Combinedtest";
    //String emoTraceFolder = new File(System.getProperty("user.dir")).getAbsolutePath() ;
	String emoTraceFolder = rootFolder + File.separator + "traces"; ;
	//String fixedEmoTraceFolder = emoTraceFolder + File.separator + "fixedtraces" ;
	String fixedEmoTraceFolder = rootFolder + File.separator + "fixedtraces" ;
    //String save         = testFolder + File.separator + "selectedtest";
    String modelFolder  = testFolder + File.separator + "Model";
    //String UdpateFolder = testFolder + File.separator + "UpdatedModel";
    String labRecruitesExeRootDir = rootFolder + File.separator + "iv4xrDemo";
    
    String emoTraceFileNamePrefix = "data_goalQuestCompleted_" ;
    
    int stuckSpan = 6 ; 
	float stuckEpsilon = 0.25f ;
	
    LabRecruitsConfig lrCfg ;
    levelsize lrsize ;
	LabRecruitsTestSuiteExecutor lrExecutor = new LabRecruitsTestSuiteExecutor(rootFolder, testFolder, modelFolder, null);
	
	public TestcasesExecRepair() { }
	
	/**
	 * The test-fixer needs to know the target Lab-recruit. Set it with this. 
	 */
	public void setTargetLRLevel(String levelName) throws IOException {
		lrCfg = new LabRecruitsConfig(levelName, modelFolder);
        lrsize= new levelsize(CSVlevelImport.ImportFromCSV(levelName, modelFolder));    
	}

    // context variables
	// WP: This does not seem to be used for anything:
	// public HashMap<Long,HashSet<Emotion>> map=new HashMap<Long,HashSet<Emotion>>();

	
	void runOneTestCase(
			String testcaseName, 
			int cyclesBudget, 
			int sleepBetweenCyclesDuration,
			StringBuffer summaryreport) 
			throws IOException {
		String testfile = testFolder + File.separator + testcaseName + ".ser" ;
		AbstractTestSequence testcase = TestSerializationUtils.loadTestSequence(testfile);
		runOneTestCase(testcase,testcaseName,cyclesBudget,sleepBetweenCyclesDuration,
				summaryreport
				) ;
	}
	
	void reprogramGoalStructure(GoalStructure G) {
		if (G instanceof PrimitiveGoal) {
			PrimitiveGoal G_ = (PrimitiveGoal) G ;
			Goal g = getGoal(G_) ;
			String prefix = "The belief on this entity is refreshed: " ;
			String name = g.getName() ;
			if (name.startsWith(prefix)) {
				String id = name.substring(prefix.length()) ;
				Goal newgoal = getGoal(entityStateRefreshed2(id)) ;
				setGoal(G_,newgoal) ;
				return ;
			}
			return ;
		}
		for (GoalStructure H : G.getSubgoals()) {
			reprogramGoalStructure(H) ;
		}
	}
	
	void runOneTestCase(
			AbstractTestSequence testcase, 
			String testcaseName, 
			int cyclesBudget, 
			int sleepBetweenCyclesDuration,
			StringBuffer summaryreport) 
			throws IOException {

		LabRecruitsEnvironment labRecruitsEnvironment = new LabRecruitsEnvironment(lrCfg);
		var dataCollector = new TestDataCollector();
		// run the testing task:
		LabRecruitsTestAgent testAgent = new LabRecruitsTestAgent("Agent1");
		testAgent.attachState(new BeliefState()).setTestDataCollector(dataCollector)
				.attachEnvironment(labRecruitsEnvironment).attachSyntheticEventsProducer(new EventsProducer());
		testAgent.getSyntheticEventsProducer().idOfLevelEnd = "gf0";
		List<GoalStructure> goals = lrExecutor.convertTestCaseToGoalStructure(testAgent, testcase);
		// uhm... we reprogram the goals:
		for (GoalStructure G : goals) reprogramGoalStructure(G) ;
		// Add instrumentation here:
		goals = (new model_test_IOoperations()).instrumentTestCase(testAgent, testcase, goals);
		GoalStructure g = SEQ(goals.toArray(new GoalStructure[goals.size()]));
		testAgent.setGoal(g);
		System.out.println(">> Testing task: " + testcaseName + ", #=" + goals.size());
		System.out.println(">> " + testcase);

		// add an event-producer to the test agent so that it produce events for
		// emotion appraisals:
		// EventsProducer eventsProducer = new
		// EventsProducer().attachTestAgent(testAgent);

		// Create an emotion appraiser, and hook it to the agent:
		EmotionAppraisalSystem eas = new EmotionAppraisalSystem(testAgent.getId());
		eas.attachEmotionBeliefBase(new EmotionBeliefBase().attachFunctionalState(testAgent.getState()))
				.withUserModel(new PlayerOneCharacterization()).addGoal(questIsCompleted, 50)
				.addGoal(gotAsMuchPointsAsPossible, 50).addInitialEmotions();
		labRecruitsEnvironment.startSimulation();
		// goal not achieved yet
		assertFalse(testAgent.success());

		// collect data
		EmotionData emodata = new EmotionData();
		int t = 0;
		boolean done = false ;
		boolean almostDone = false ;
		// giving this many extra turn-updates after the goal is accomplished/aborted,
		// or after satisfaction/disappointment is triggered. This is mainly so that
		// the agent has the opportunity to update its state with the new score/health.
		// While the state is updated in the SUT, the agent is only aware of that in the
		// at the start of the next update turn, where it samples the SUT state.
		int extraTurnsAtTheEnd = 1 ; 
		while (!done) {
			Vec3 position = testAgent.getState().worldmodel.position;
			System.out.println("*** " + t + ", " + testAgent.getState().id + " @" + position);
			
			//WorldEntity door1 = testAgent.getState().worldmodel.elements.get("door1") ;
			//System.out.println(">>> door1 open="
			//		+ (door1 != null ? door1.properties.get("isOpen") : "null")) ;
			
			//Boolean d1change = null ;
			//if (testAgent.getState().changedEntities != null)
			//	d1change = testAgent.getState().changedEntities.stream()
			//			.anyMatch(e -> e.id.equals("door1")) ;
			//System.out.println(">>> door1 changes state: " + d1change) ; 
			//WorldEntity gf0_ = testAgent.getState().worldmodel.elements.get("gf0") ;
			
			//System.out.println(">>> gf0 "
			//		+ (gf0_ != null ? "dist:" + Vec3.dist(position, gf0_.position): "null")) ;
			//System.out.println(">>> #events:" + testAgent.getSyntheticEventsProducer().currentEvents.size()) ;
			//System.out.println(">>> levelCompleted-event-generated: " 
			//		+ testAgent.getSyntheticEventsProducer().trace.stream()
			//		     .anyMatch(m -> EventsProducer.isLevelCompletedEvent(m)
			//		    		 )) ;
			
			if (testAgent.getSyntheticEventsProducer().currentEvents.isEmpty()) {
				eas.update(new Tick(), t);
			} else {
				for (Message m : testAgent.getSyntheticEventsProducer().currentEvents) {
					eas.update(new LREvent(m.getMsgName()), t);
					// WP: map does not seem to be used for anything. Commenting out:
					//if (!eas.newEmotions.isEmpty()) {
					//	map.put(testAgent.getState().worldmodel.timestamp, eas.newEmotions);
					//}

				}
			}

			if (position != null) {

				Float score = (float) testAgent.getState().worldmodel().score;
				Float healthlost = (float) testAgent.getState().worldmodel().healthLost;
				Float health = (float) testAgent.getState().worldmodel().health;
				System.out.println("*** score=" + score);
				emodata.recordNewrow(score, healthlost, health, eas, position, t);
				if (eas.newEmotions.stream().anyMatch(c -> c.etype == Emotion.EmotionType.Disappointment)
						|| eas.newEmotions.stream().anyMatch(c -> c.etype == Emotion.EmotionType.Satisfaction)) {
					almostDone = true;
				}
			}
			if (t > cyclesBudget) {
				break;
			}
			try {
				Thread.sleep(sleepBetweenCyclesDuration);
				testAgent.update();

			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			t++;
			done = extraTurnsAtTheEnd == 0 ;
			if (!g.getStatus().inProgress()) {
				almostDone = true ;
			}
			if (almostDone) extraTurnsAtTheEnd-- ;
			
		}
		// int x=43+i;
		// save triggered emotions 
		String traceFile = fixedEmoTraceFolder 
				+ File.separator + "tmp" + File.separator
				+ emoTraceFileNamePrefix + testcaseName + ".csv" ;
		exportToCSV(emodata.csvData_goalQuestIsCompleted,traceFile);
		// exportToCSV(emodata.csvData_goalGetMuchPoints,
		// "data_goalGetMuchPoints_"+i+".csv");

		//g.printGoalStructureStatus();
		labRecruitsEnvironment.close();

		if (summaryreport!=null) {
			summaryreport.append(">> tc-" + testcaseName + ", Duration: " + t + ", goalstatus: " + g.getStatus()
			+ ", #fail: " + testAgent.getTestDataCollector().getNumberOfFailVerdictsSeen() + ", #success: "
			+ testAgent.getTestDataCollector().getNumberOfPassVerdictsSeen() + "\n");
		}
	}
	
	public enum TerminationType {
		TERMINATE_NORMAL,
		TERMINATE_TIMEOUT,
		TERMINATE_STUCK
	}
	
	/**
	 * Check an emotion-trace file to determine how the test-case that produces it
	 * terminates. The agent terminates normally when it ends in satisfaction>0 or 
	 * in disappointment>0, of if the update-count in the
	 * trace is <= the given time limit (in number of updates/cycles), or if it
	 * to the test case when producing the trace file.
	 * 
	 * Otherwise the agent either terminates by timeout or by stuck. It terminates
	 * by stuck if the last k positions in the trace file are "close" to each other.
	 * This is defined by checking if the distance between each position(#N - i - 1)
	 * and position(#N-1) is less than a certain epsilon; where 0<i<k.
	 * If this is the case the agent is identified as stuck, and it terminates by
	 * stuck.
	 * 
	 * Otherwise it terminates by timeout.
	 * 
	 * @param emoTracesDir
	 * @param emoTraceFile
	 * @param timeLimit  the given time limit (in number of updates/cycles) to the 
	 *                   test case when producing the trace file.
	 * @param stuckSpan  the number of cycles where stuck will be checked. E.g. when
	 *                   this is 4, we will be checking the last four entries in
	 *                   the trace-file to determine whether the agent was stucked
	 *                   or not.
	 * @param stuckEpsilon  the epsilon distance for checking stuck.
	 */
	TerminationType checkTestCaseTerminationType(String emoTraceFile,int timeLimit) 
			throws IOException {
		
		String prefix = "data_goalQuestCompleted_" ;
		String file = fixedEmoTraceFolder + File.separator + "tmp" + File.separator + emoTraceFile ;
		
		String tcname = emoTraceFile.substring(prefix.length(), emoTraceFile.length() - 4)  ;
		
		List<String[]> data = CSVUtility.readCSV(',',file) ;
		if (data.size()<2) throw new IOException("The file " + file + " has no data.") ;
		int lastTurn =  Integer.parseInt(data.get(data.size()-1)[0]) ;
		float lastSatisfaction   = Float.parseFloat(data.get(data.size()-1)[5]) ;
		float lastDisappointment = Float.parseFloat(data.get(data.size()-1)[8]) ;
		
		if (lastTurn <= timeLimit || lastSatisfaction>0 || lastDisappointment>0) 
			return TerminationType.TERMINATE_NORMAL ;
		
		if (stuckSpan < 2)
			return TerminationType.TERMINATE_TIMEOUT ;
		
		Vec3 p0 = null ;
		for (int k=0; k<stuckSpan; k++) {
			String[] row = data.get(data.size() - k - 1 ) ;
			Vec3 p = new Vec3(Float.parseFloat(row[1]), Float.parseFloat(row[2]), 0f) ;
			if (p0 == null)
				p0 = p ;
			else {
				float dist = Vec3.dist(p0,p) ;
				System.out.println(">>>> p0=" + p0 
						+ " k=" + k 
						+ " p=" + p
						+ " dist=" + dist) ;
				if (dist > stuckEpsilon)
					return TerminationType.TERMINATE_TIMEOUT ;
			}
		}
		return TerminationType.TERMINATE_STUCK ;
	}
	
	String getTesCaseId(String traceFileName) {
		return traceFileName.substring(emoTraceFileNamePrefix.length(), traceFileName.length()-4) ;
	}
	
	
	/**
	 * Worker method to fix a single test-case. Using recursion to retrying executing
	 * the test-case until it works.
	 */
	void fixOneTestCaseWorker(
			String testcaseName,
			TerminationType currentTerminationType,
			int budget,
			int budgetIncrement,
			int maxBudget,
			int maxNumberOfRetryOnStuck,
			int numberOfStuckRetriesLeft
			) throws IOException {
		
		String traceFileName = "" + emoTraceFileNamePrefix + testcaseName + ".csv" ;
		
		if (currentTerminationType == TerminationType.TERMINATE_NORMAL) return ;
		if (currentTerminationType == TerminationType.TERMINATE_TIMEOUT && budget > maxBudget) {
			System.out.println("** " + testcaseName  
					+ " still timed-out, but we have achieved max-budget. Will not try further.") ;
			String source = fixedEmoTraceFolder + File.separator + "tmp" + File.separator + traceFileName ;
			String target = fixedEmoTraceFolder + File.separator + "timeout_unfixed" + File.separator + traceFileName ;
			Files.copy(Paths.get(source), Paths.get(target)) ;			
			return ;
		}
		if (currentTerminationType == TerminationType.TERMINATE_STUCK && numberOfStuckRetriesLeft==0) {
			System.out.println("** " + testcaseName  
					+ " still stuck, but we exhausted number of retries. Will not try further.") ;
			String source = fixedEmoTraceFolder + File.separator + "tmp" + File.separator + traceFileName ;
			String target = fixedEmoTraceFolder + File.separator + "stuck_unfixed" + File.separator + traceFileName ;
			Files.copy(Paths.get(source), Paths.get(target)) ;			
			return ;
		}
		// retry-the test:
		StringBuffer summaryreport = new StringBuffer();
		runOneTestCase(testcaseName,budget,200,summaryreport) ;
		var previousTerminationType = currentTerminationType ;
		currentTerminationType = checkTestCaseTerminationType(traceFileName,budget) ;
		System.out.println("** testcaseName did not terminate. so it was re-ran it. Budget: " + budget) ;
		System.out.println("**    " + summaryreport.toString()) ;
		System.out.println("**    new termination status: " + currentTerminationType) ;  
		
		if (currentTerminationType == TerminationType.TERMINATE_NORMAL) {
			System.out.println("**    fix SUCCESS!") ;
			String source = fixedEmoTraceFolder + File.separator + "tmp" + File.separator + traceFileName ;
			String target = fixedEmoTraceFolder + File.separator + "fixed" + File.separator + traceFileName ;
			Files.copy(Paths.get(source), Paths.get(target)) ;
			return ;
		}
		if (currentTerminationType == TerminationType.TERMINATE_TIMEOUT) {
			fixOneTestCaseWorker(testcaseName,currentTerminationType,
					budget+budgetIncrement,
					budgetIncrement,
					maxBudget,
					maxNumberOfRetryOnStuck,maxNumberOfRetryOnStuck) ;
			return ;
		}
		// else currentTerminationType must be STUCK:
		if (previousTerminationType == TerminationType.TERMINATE_TIMEOUT) 
			numberOfStuckRetriesLeft = maxNumberOfRetryOnStuck ;
		else 
			numberOfStuckRetriesLeft = numberOfStuckRetriesLeft - 1 ;
		fixOneTestCaseWorker(testcaseName,currentTerminationType,
			budget,
			budgetIncrement,
			maxBudget,
			maxNumberOfRetryOnStuck,numberOfStuckRetriesLeft) ;
	}
	
	
	private void clearFolder(String path) throws IOException {
		Files.createDirectories(Paths.get(path)) ;
		List<File> files = org.apache.maven.shared.utils.io.FileUtils.getFiles(new File(path), "*.csv", "");
		for (File f : files) {
			java.nio.file.Path fp = Paths.get(f.getAbsolutePath()) ;
			Files.delete(fp);
		}
	}
	void prepareOutputDirs() throws IOException {
		clearFolder(fixedEmoTraceFolder + File.separator + "alreadyOk") ;
		clearFolder(fixedEmoTraceFolder + File.separator + "fixed") ;
		clearFolder(fixedEmoTraceFolder + File.separator + "timeout_unfixed") ;
		clearFolder(fixedEmoTraceFolder + File.separator + "stuck_unfixed") ;
		clearFolder(fixedEmoTraceFolder + File.separator + "tmp") ;	
		List<File> files = org.apache.maven.shared.utils.io.FileUtils.getFiles(new File(emoTraceFolder), "*.csv", "");
		for (File f : files) {
			java.nio.file.Path fp = Paths.get(f.getAbsolutePath()) ;
			String target = fixedEmoTraceFolder + File.separator + "tmp" + File.separator + f.getName() ;
			Files.copy(fp, Paths.get(target)) ;
		}
	}
	
	/**
	 * This is the main API for this class. It will run the fixing algorithm to fix existing
	 * traces produced by test cases. Example use:
	 * 
	 *      new TestcaseExecRepair()
	 *      . fixTestCasesRuns(false,"level-name",500,500,2000,2);
	 *      
	 * @param graphicsOn   When true, the fixer will run with graphics visible.
	 * @param LRlevel      The target lab-recruit level to test.
	 * @param startBudget  The budget used to produce the original traces.
	 * @param budgetIncrement  When the fixer retries time-out cases, each time it will increase
	 *                         the budget with this amount
	 * @param maxBudget    The max-budget the fixer will try.
	 * @param maxNumberOfRetryOnStuck  The maximum number of retries for the stuck-cases. 
	 */
	public void fixTestCasesRuns(
			boolean graphicsOn,
			String LRlevel,
			int startBudget,
			int budgetIncrement,
			int maxBudget,
			int maxNumberOfRetryOnStuck
			) throws IOException {
		System.out.println("** ==== Running test-cases fixer.") ;
		setTargetLRLevel(LRlevel) ;
		// open the LR server
		LabRecruitsTestServer testServer = new LabRecruitsTestServer(
        		graphicsOn, // set to true to see graphics
                Platform.PathToLabRecruitsExecutable(labRecruitesExeRootDir));
		
		prepareOutputDirs() ;
		String workingTmpDir = fixedEmoTraceFolder + File.separator + "tmp" ;
        try {
        	List<File> files = org.apache.maven.shared.utils.io.FileUtils.getFiles(new File(workingTmpDir), "*.csv", "");
			for (File file : files) {
				if (! file.getName().startsWith(emoTraceFileNamePrefix)) continue ;
				var terminationType = checkTestCaseTerminationType(file.getName(),startBudget) ; 
				if(terminationType == TerminationType.TERMINATE_NORMAL) {
					java.nio.file.Path fp = Paths.get(file.getAbsolutePath()) ;
					String target = fixedEmoTraceFolder + File.separator + "alreadyOk" + File.separator + file.getName() ;
					Files.copy(fp, Paths.get(target)) ;
					continue ;
				}
				// the test-case didn't terminate normally; fix it:
				String testcaseName = getTesCaseId(file.getName()) ;
				int budget = startBudget ;
				int numberOfStuckRetriesLeft = maxNumberOfRetryOnStuck ;
				if (terminationType == TerminationType.TERMINATE_TIMEOUT) {
					budget += budgetIncrement ;
				}
				else {
					numberOfStuckRetriesLeft = numberOfStuckRetriesLeft - 1 ;
				}
				fixOneTestCaseWorker(
							testcaseName,
							terminationType,
							budget,
							budgetIncrement,
							maxBudget,
							maxNumberOfRetryOnStuck,
							numberOfStuckRetriesLeft) ;
			}	
			clearFolder(fixedEmoTraceFolder + File.separator + "tmp") ;	
			System.out.println("** ==== Done with test-cases fixing.") ;
        	//System.out.println("Hit RETURN to continue.") ;
    		//new Scanner(System.in) . nextLine() ;
        }
        finally {
        	testServer.close();
        }
	}
	
	//@Test
	void cobaRunOneTest() throws IOException {
		setTargetLRLevel("Wave-the-flag_MRF_f0_z0_51");
		LabRecruitsTestServer testServer = new LabRecruitsTestServer(
        		true, // set to true to see graphics
                Platform.PathToLabRecruitsExecutable(labRecruitesExeRootDir));
		StringBuffer summaryreport = new StringBuffer() ;
		runOneTestCase("SBTtest_55", 800, 200, summaryreport)  ;
		System.out.println(">>> " + summaryreport) ;
		System.out.println("Hit RETURN to continue.") ;
		new Scanner(System.in) . nextLine() ;
		testServer.close();
	}
	
	@Test
	public void runRepair() throws IOException {
		String levelName = Utils.autoGetLevelName(modelFolder) ;
		fixTestCasesRuns(withGraphics,levelName,500,500,2000,2);
	}
	
	// Just for testing the APIs:
	public static void main(String[] args) throws IOException {
		
		/*
		var ty = new TestcaseExecRepair() 
			. checkTestCaseTerminationType(
					"data_goalQuestCompleted_SBTtest_55.csv",
					500,
					4,
					0.4f) ;
		System.out.println(">>>> " + ty) ; */
		
		//new TestcaseExecRepair() . cobaRunOneTest() ;
		//new TestcaseExecRepair() . prepareOutputDirs();
		
		new TestcasesExecRepair()
		. fixTestCasesRuns(false,"Wave-the-flag_MRF_f0_z0_51",500,500,2000,2);
		
	}

}
